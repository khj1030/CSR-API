<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>마이크 녹음</title>
</head>
<body>
    <!-- <button>시작/종료</button>
    <br><br>
    <audio controls>녹음된 소리를 재생할 audio 엘리먼트</audio> -->

    <text>
      "음성 인식 api/lib를 통한 음성을 Text로 변형, 제 2가공으로 처리하는 프로그램을 작성"<br>
      "Voice > Text > another Languagee"
    </text>
    <br>
    <button id="rcdStart" >Record</button>
    <button id="rcdStop">Stop</button>
    <input type="text" id="resultList" value="undefined" size="80"/>

</body>
<script>

    // // 엘리먼트 취득
    // const $audioEl = document.querySelector("audio");
    // const $btn = document.querySelector("button");

    // // 녹음중 상태 변수
    // let isRecording = false;

    // // MediaRecorder 변수 생성
    // let mediaRecorder = null;

    // // 녹음 데이터 저장 배열
    // const audioArray = [];

    // $btn.onclick = async function (event) {
    //     if(!isRecording){

    //         // 마이크 mediaStream 생성: Promise를 반환하므로 async/await 사용
    //         const mediaStream = await navigator.mediaDevices.getUserMedia({audio: true});

    //         // MediaRecorder 생성
    //         mediaRecorder = new MediaRecorder(mediaStream);

    //         // 이벤트핸들러: 녹음 데이터 취득 처리
    //         mediaRecorder.ondataavailable = (event)=>{
    //             audioArray.push(event.data); // 오디오 데이터가 취득될 때마다 배열에 담아둔다.
    //         }

    //         // 이벤트핸들러: 녹음 종료 처리 & 재생하기
    //         mediaRecorder.onstop = (event)=>{
                
    //             // 녹음이 종료되면, 배열에 담긴 오디오 데이터(Blob)들을 합친다: 코덱도 설정해준다.
    //             const blob = new Blob(audioArray, {"type": "audio/mpeg codecs=opus"});
    //             audioArray.splice(0); // 기존 오디오 데이터들은 모두 비워 초기화한다.
                
    //             // Blob 데이터에 접근할 수 있는 주소를 생성한다.
    //             const blobURL = window.URL.createObjectURL(blob);

    //             console.log(blob);

    //             // audio엘리먼트로 재생한다.
    //             $audioEl.src = blobURL;
    //             $audioEl.play();

    //         }

    //         // 녹음 시작
    //         mediaRecorder.start();
    //         isRecording = true;

    //     }else{
    //         // 녹음 종료
    //         mediaRecorder.stop();
    //         isRecording = false;
    //     }
    // }

    if(!("webkitSpeechRecognition") in window){
        alert("Connect in Chrome Browser");
    }else{
        const speech = new webkitSpeechRecognition;

        document.getElementById("rcdStart").addEventListener("click",()=>{
            speech.start();
        });
        document.getElementById("rcdStop").addEventListener("click",()=>{
            speech.stop();
        });

        speech.addEventListener("result", (event)=>{
            console.log(event);
            const { transcript } = event["results"][0][0];
            console.log(transcript);
            resultListView(transcript);
        });

        function resultListView(transcript){
            document.getElementById("resultList").value = transcript;
        }
    }

</script>

</html>